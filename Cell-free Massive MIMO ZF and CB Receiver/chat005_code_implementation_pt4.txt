
 ▐▛███▜▌   Claude Code v2.1.50
▝▜█████▛▘  Opus 4.6 · Claude Max
  ▘▘ ▝▝    F:\Codes\Awesome-Wireless-Communications

✻ Conversation compacted (ctrl+o for history)

  ⎿  Read paper implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\main_fig2.m (91 lines)
  ⎿  Read paper implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\compute_SE_ZF_montecarlo.m (77 lines)
  ⎿  Read paper implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\compute_SE_ZF.m (63 lines)
  ⎿  Read paper implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\compute_SE_CB.m (76 lines)
  ⎿  Read C:\Users\acer\.claude\todos\23641fc2-4f32-412b-8c5b-8bcff56a0094-agent
     -23641fc2-4f32-412b-8c5b-8bcff56a0094.json (1 lines)

● I'll continue implementing Steps 10-13. Let me first read the necessary
  context files.

● Read 2 files (ctrl+o to expand)

● Explore(Extract power control equations from paper)
  ⎿  Done (14 tool uses · 67.5k tokens · 1m 46s)
  (ctrl+o to expand)

● Now let me read the detailed analysis document for the exact SCA/GP
  formulations.

● Searched for 4 patterns, read 1 file (ctrl+o to expand)

● The analysis document is light on the exact SCA/GP equations. Let me read the
  paper PDF directly to get the precise formulations.

● Searched for 1 pattern, read 2 files (ctrl+o to expand)

● Let me search for the Figure 3 description in the analysis and also check if
  there's a Numerical Results section.

● Searched for 2 patterns (ctrl+o to expand)

● Now I have all the equations and context. Let me implement Steps 10-13. I'll
  create all 5 files.

● Read 1 file (ctrl+o to expand)

● Good, I have all the context. Now let me write all 5 files.

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_fig3.m)
  ⎿  Wrote 90 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_fig3.m
     % main_fig3.m — Reproduce Figure 3: CDF of per-user spectral 
     efficiency
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Figure 3
     %
     % Plots the empirical CDF of per-user SE for ZF and CB receivers
     % with equal power control (eta_k = 1), comparing:
     %   - tau = 10 (orthogonal pilots, no pilot contamination since K = 
     10)
     %   - tau = 8  (pilot contamination, since tau < K)
     %
     % Fixed: M = 60, K = 10, N = 6.
     … +80 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\power_control_SCA_ZF.m)
  ⎿  Wrote 124 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\power_control_SCA_ZF.m
     function eta = power_control_SCA_ZF(beta, alpha, pilot_index, p, R_bar)
     %POWER_CONTROL_SCA_ZF Algorithm 1: SCA for ZF total rate maximization 
     (Eq. 21-29).
     %   eta = power_control_SCA_ZF(beta, alpha, pilot_index, p)
     %   eta = power_control_SCA_ZF(beta, alpha, pilot_index, p, R_bar)
     %
     %   Eq. 21:  maximize    SUM_k R_k^ZF({eta_k})
     %            subject to  R_k^ZF >= R_bar_k,  for all k   (QoS 
     constraint)
     %                        0 <= eta_k <= 1                  (power 
     constraint)
     %
     %   where R_k^ZF = prelog * log2(1 + a_k * eta_k / D)  (Theorem 1, Eq. 
     16)


     … +114 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\power_control_SCA_CB.m)
  ⎿  Wrote 123 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\power_control_SCA_CB.m
     function eta = power_control_SCA_CB(beta, alpha, pilot_index, p, R_bar)
     %POWER_CONTROL_SCA_CB Algorithm 3: SCA for CB total rate maximization 
     (Eq. 36-43).
     %   eta = power_control_SCA_CB(beta, alpha, pilot_index, p)
     %   eta = power_control_SCA_CB(beta, alpha, pilot_index, p, R_bar)
     %
     %   Eq. 36:  maximize    SUM_k R_k^CB({eta_k})
     %            subject to  R_k^CB >= R_bar_k,  for all k   (QoS 
     constraint)
     %                        0 <= eta_k <= 1                  (power 
     constraint)
     %
     %   where R_k^CB = prelog * log2(1 + eta_k * S_k / D_k)  (Lemma 1, Eq. 
     33)


     … +113 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\power_control_GP_ZF.m)
  ⎿  Wrote 93 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\power_control_GP_ZF.m
     function eta = power_control_GP_ZF(beta, alpha, pilot_index, p, R_bar)
     %POWER_CONTROL_GP_ZF Algorithm 2: GP for ZF single-user rate max (Eq. 
     30-31).
     %   eta = power_control_GP_ZF(beta, alpha, pilot_index, p)
     %   eta = power_control_GP_ZF(beta, alpha, pilot_index, p, R_bar)
     %
     %   Eq. 30:  maximize    R_1^ZF
     %            subject to  R_k^ZF >= R_bar_k,  k = 2,...,K   (QoS for 
     others)
     %                        0 <= eta_k <= 1                    (power)
     %
     %   ZF SINR (Eq. 16):
     … +83 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\power_control_GP_CB.m)
  ⎿  Wrote 95 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\power_control_GP_CB.m
     function eta = power_control_GP_CB(beta, alpha, pilot_index, p, R_bar)
     %POWER_CONTROL_GP_CB Algorithm 4: GP for CB single-user rate max (Eq. 
     44-45).
     %   eta = power_control_GP_CB(beta, alpha, pilot_index, p)
     %   eta = power_control_GP_CB(beta, alpha, pilot_index, p, R_bar)
     %
     %   Eq. 44:  maximize    R_1^CB
     %            subject to  R_k^CB >= R_bar_k,  k = 2,...,K   (QoS for 
     others)
     %                        0 <= eta_k <= 1                    (power)
     %
     %   CB SINR (Lemma 1, Eq. 33):
     … +85 lines (ctrl+o to expand)

● All 5 files are written. Now let me update the memory file and then provide
  the detailed line-by-line explanations.

● Recalled 1 memory, wrote 1 memory (ctrl+o to expand)

● Now here are the detailed line-by-line explanations for each step:

  ---
  Step 10: main_fig3.m — CDF of Per-User Spectral Efficiency (Figure 3)

  What this figure shows

  Figure 3 plots the Cumulative Distribution Function (CDF) of per-user SE.
  Unlike Figure 2 (which showed sum rate vs M), this figure shows how individual
   user rates are distributed — revealing fairness and outage behavior. It
  compares:
  - ZF vs CB at tau=10 (orthogonal pilots, no contamination)
  - ZF vs CB at tau=8 (pilot contamination since tau < K=10)

  Line-by-line explanation

  p = params();
  tau_vec    = [10, 8];
  num_setups = p.num_setups;
  We test two pilot lengths: tau=10 means each of K=10 users gets a unique pilot
   (no contamination). tau=8 forces 2 users to share pilots, creating pilot 
  contamination.

  for it = 1:length(tau_vec)
      p.tau    = tau_vec(it);
      p.prelog = 1 - p.tau / p.T;
  The pre-log factor changes with tau. For tau=10: prelog = 1 - 10/200 = 0.95.
  For tau=8: prelog = 1 - 8/200 = 0.96. Less pilot overhead means more data
  time.

      all_ZF = zeros(p.K, num_setups);
      all_CB = zeros(p.K, num_setups);
  We store per-user rates (K users x num_setups). For the CDF, we'll flatten
  this into a single vector of K*num_setups = 1000 samples.

          [beta, ~, ~] = generate_setup(p);
          pilot_index = assign_pilots(p.K, p.tau);
          [alpha, ~] = estimate_channel(beta, pilot_index, p);
  Standard pipeline: generate network, assign pilots, compute MMSE parameters.
  When tau=8, assign_pilots does random assignment (some users share pilots).

          all_ZF(:, s) = compute_SE_ZF(beta, alpha, pilot_index, p);
          all_CB(:, s) = compute_SE_CB(beta, alpha, pilot_index, p);
  Closed-form SE for each user. Equal power control (eta_k = 1 by default).

      rates_ZF{it} = all_ZF(:);
  all_ZF(:) flattens the K x num_setups matrix into a single column — giving us
  1000 per-user rate samples to build the CDF from.

      [f_zf, x_zf] = ecdf(rates_ZF{it});
      plot(x_zf, f_zf, '-',  'Color', colors{it}, 'LineWidth', 1.5);
  MATLAB's ecdf computes the empirical CDF. x_zf = sorted rate values, f_zf =
  corresponding cumulative probabilities. Solid lines = ZF, dashed lines = CB.
  Blue = tau=10, red = tau=8.

      zf_5  = prctile(rates_ZF{it}, 5);
  The 5th percentile (5%-outage rate) is a key fairness metric: it's the rate
  that 95% of users exceed. From the paper: ZF at tau=10 gives ~2.5 bits/s/Hz,
  while dropping to tau=8 causes a dramatic drop.

  ---
  Step 11: power_control_SCA_ZF.m — Algorithm 1 (SCA for ZF Sum-Rate)

  The optimization problem (Eq. 21)

  $$\max_{{\eta_k}} \sum_{k=1}^{K} R_k^{ZF} \quad \text{s.t.} \quad R_k^{ZF}
  \geq \bar{R}_k, \quad 0 \leq \eta_k \leq 1$$

  Where from Theorem 1 (Eq. 16):

  $$R_k^{ZF} = \left(1 - \frac{\tau}{T}\right) \log_2!\left(1 + \frac{\rho_u ,
  \Omega(k) , \eta_k}{\rho_u \sum_{i=1}^K \eta_i c_i + 1}\right)$$

  Why is this hard?

  The sum of log-ratio functions is neither convex nor concave in {eta_k}.
  Writing it as:

  $$\sum_k R_k = \sum_k \underbrace{\log_2(a_k \eta_k + D)}{\text{concave in } 
  \eta} - K \underbrace{\log_2(D)}{\text{concave in } \eta}$$

  where $a_k = \rho_u \Omega_k$ and $D = \rho_u \sum_i \eta_i c_i + 1$, we see
  it's difference of concave (DC) functions — NP-hard in general.

  The SCA approach

  At iteration n, linearize the subtracted concave term $g(\eta) = K \ln(D)$:

  $$g(\eta) \approx g(\eta^{(n)}) + \nabla g(\eta^{(n)})^\top (\eta -
  \eta^{(n)})$$

  where $\frac{\partial g}{\partial \eta_j} = \frac{K \rho_u c_j}{D^{(n)}}$.

  This gives a concave lower bound on the original objective. Maximizing this
  lower bound yields the next iterate.

  Line-by-line explanation

      c_err = max(beta - alpha, [], 1).';       % K x 1
  Eq. 17: $c_i = \max_m (\beta_{mi} - \alpha_{mi})$. The worst-case channel 
  estimation error across all APs for user i. max(·, [], 1) takes the max over
  rows (APs), giving a 1 x K row, then .' transposes to K x 1.

      [~, dominant_ap] = max(beta, [], 1);      % 1 x K
  Eq. 20: $m_j^* = \arg\max_m \beta_{mj}$. The AP with strongest channel to user
   j. Used to build the set M_k.

      for k = 1:K
          excluded = dominant_ap([1:k-1, k+1:K]);
          Mk = setdiff(1:M, excluded);
  Eq. 19: $\mathcal{M}_k = {1,\ldots,M} \setminus {m_j^* : j \neq k}$. Exclude
  the dominant AP of every other user. User k keeps its own dominant AP.

          alpha_Mk = alpha(Mk, k);
          S1 = sum(alpha_Mk);
          S2 = sum(alpha_Mk.^2);
          Omega_k = (p.N * S1^2 - S2) / S1;
          a(k) = p.rho_u * Omega_k;
  Eq. 18: $\Omega(k) = \frac{N \cdot S_1^2 - S_2}{S_1}$ where $S_1 = \sum_{m \in
   \mathcal{M}k} \alpha{mk}$ and $S_2 = \sum_{m \in \mathcal{M}k} \alpha{mk}^2$.
   Then $a_k = \rho_u \cdot \Omega(k)$ is the numerator coefficient for user k's
   SINR.

      gamma = 2.^(R_bar / p.prelog) - 1;
  Convert QoS rate targets to SINR thresholds: $R_k \geq \bar{R}_k
  \Leftrightarrow \text{SINR}_k \geq \gamma_k$ where $\gamma_k = 2^{\bar{R}_k /
  \text{prelog}} - 1$.

      eta = ones(K, 1);
  Initial point: equal power control (all eta_k = 1). This is always feasible
  when R_bar = 0.

          D_n = p.rho_u * (c_err' * eta) + 1;
  Evaluate denominator at current point: $D^{(n)} = \rho_u \sum_i \eta_i^{(n)}
  c_i + 1$. This is a scalar since c_err' * eta is a dot product.

          d = K * p.rho_u * c_err / D_n;
  Gradient of the linearized term: $d_j = \frac{K \rho_u c_j}{D^{(n)}}$. These
  are the coefficients of the affine penalty term in the subproblem.

          cvx_begin quiet
              variable eta_new(K, 1)
              obj = -d' * eta_new;
              for k = 1:K
                  obj = obj + log(a(k) * eta_new(k) ...
                              + p.rho_u * (c_err' * eta_new) + 1);
              end
              maximize(obj)
  CVX subproblem: The objective is $\sum_k \ln(a_k \eta_k + D) - \mathbf{d}^\top
   \boldsymbol{\eta}$. The first part is concave (log of affine), the second is
  affine. Their sum is concave — valid for maximize in CVX.

  Inside the log: a(k) * eta_new(k) + rho_u * (c_err' * eta_new) + 1 is the
  quantity $a_k \eta_k + D = a_k \eta_k + \rho_u \sum_i \eta_i c_i + 1$ — the
  numerator-plus-denominator of the SINR.

                  for k = 1:K
                      if gamma(k) > 0
                          a(k) * eta_new(k) ...
                              - gamma(k) * p.rho_u * (c_err' * eta_new) >=
  gamma(k);
                      end
                  end
  QoS constraint (linear): $\text{SINR}_k \geq \gamma_k \Leftrightarrow a_k
  \eta_k \geq \gamma_k D \Leftrightarrow a_k \eta_k - \gamma_k \rho_u \sum_i
  \eta_i c_i \geq \gamma_k$. This is an affine inequality in eta — always
  convex.

          if norm(eta_new - eta) < epsilon
              eta = eta_new;
              break;
          end
  Convergence check: stop when the power coefficients barely change. The paper
  shows convergence in ~4 iterations (Fig. 5).

  ---
  Step 12: power_control_SCA_CB.m — Algorithm 3 (SCA for CB Sum-Rate)

  The key difference from ZF

  For CB (Lemma 1, Eq. 33), each user has its own denominator:

  $$\text{SINR}k^{CB} = \frac{\eta_k \cdot S_k}{D_k}, \quad D_k = \sum{j=1}^K
  \eta_j \cdot w_{jk} + \text{noise}_k$$

  where:
  - $S_k = |\mathbf{l}{kk}|^2 = \sum_m \alpha{mk}^2$ (Eq. 34 with i=k)
  - $w_{jk}$ = interference weight from user j to user k
  - $\text{noise}k = \sum_m \alpha{mk} / (N \rho_u)$

  Line-by-line explanation (focusing on what's different from ZF)

      S = sum(alpha.^2, 1).';
  Signal power for each user: $S_k = |\mathbf{l}_{kk}|2^2 = \sum_m 
  \alpha{mk}^2$. sum(·,1) sums over rows (APs).

      w = zeros(K, K);
      for k = 1:K
          for i = 1:K
              noncoh = sum(beta(:, i) .* alpha(:, k)) / p.N;
  Eq. 35: Non-coherent interference weight: $|\boldsymbol{\theta}{ik}|^2/N = 
  \frac{1}{N}\sum_m \beta{mi} \alpha_{mk}$. This is always present for every
  (i,k) pair, including i=k (self non-coherent interference).

              coh = 0;
              if i ~= k && pilot_index(i) == pilot_index(k)
                  l_ik = alpha(:, k) .* beta(:, i) ./ beta(:, k);
                  coh = sum(l_ik.^2);
              end
  Eq. 34: Coherent interference: $|\mathbf{l}{ik}|^2$ only exists when $i \neq 
  k$ AND users share the same pilot ($|\boldsymbol{\phi}k^H \boldsymbol{\phi}i| 
  = 1$). The vector $\mathbf{l}{ik} = [\alpha{1k} \beta{1i}/\beta_{1k}, \ldots,
  \alpha_{Mk} \beta_{Mi}/\beta_{Mk}]^\top$.

              w(i, k) = coh + noncoh;
  Total interference weight: $w_{ik} = |\mathbf{l}{ik}|^2 \cdot 
  \mathbb{1}(\text{co-pilot}, i{\neq}k) + |\boldsymbol{\theta}{ik}|^2/N$.

      noise = sum(alpha, 1).' / (p.N * p.rho_u);
  Noise term: $\text{noise}k = \frac{|\mathbf{l}{kk}|1}{N \rho_u} = \frac{\sum_m
   \alpha{mk}}{N \rho_u}$. Note ||l_kk||_1 (1-norm) vs ||l_kk||_2^2 (squared
  2-norm) used in the signal.

          D_n = w' * eta + noise;
  Per-user denominators at current point: $D_k^{(n)} = \sum_j \eta_j^{(n)}
  w_{jk} + \text{noise}_k$. This is K x 1 (one per user), unlike ZF where D was
  a scalar. w' is K x K, so w' * eta gives a K x 1 vector.

                  obj = obj + log(eta_new(k) * S(k) ...
                              + w(:,k)' * eta_new + noise(k));
                  obj = obj - w(:,k)' * eta_new / D_n(k);
  Subproblem objective for user k:
  - Concave part: $\ln(\eta_k S_k + D_k)$ where $D_k = \mathbf{w}_{:,k}^\top
  \boldsymbol{\eta} + \text{noise}_k$
  - Linearized penalty: $-\frac{\mathbf{w}_{:,k}^\top
  \boldsymbol{\eta}}{D_k^{(n)}}$ (gradient of $-\ln(D_k)$ at $\eta^{(n)}$)

  The key difference from ZF: each user k has its own denominator $D_k$ and its
  own gradient term, whereas ZF had a single shared denominator.

                          S(k) * eta_new(k) ...
                              - gamma(k) * (w(:,k)' * eta_new) >= gamma(k) *
  noise(k);
  QoS constraint: $S_k \eta_k \geq \gamma_k D_k \Leftrightarrow S_k \eta_k -
  \gamma_k \mathbf{w}_{:,k}^\top \boldsymbol{\eta} \geq \gamma_k \cdot
  \text{noise}_k$. Still linear in eta.

  ---
  Step 13: GP Power Control — power_control_GP_ZF.m (Alg. 2) & 
  power_control_GP_CB.m (Alg. 4)

  The single-user optimization problem (Eq. 30/44)

  $$\max_{{\eta_k}} R_1 \quad \text{s.t.} \quad R_k \geq \bar{R}_k \ (k \geq 2),
   \quad 0 \leq \eta_k \leq 1$$

  Maximize user 1's rate while all other users meet QoS. This is a Geometric 
  Program (GP) — solvable globally (no iterations needed, unlike SCA).

  The log-domain reformulation trick

  Define $x_k = \ln(\eta_k)$, so $\eta_k = e^{x_k}$ and the power constraint
  becomes $x_k \leq 0$.

  For ZF (common denominator):

  $$\ln(\text{SINR}k) = \ln(a_k) + x_k - \underbrace{\ln!\left(\rho_u \sum_i c_i
   e^{x_i} + 1\right)}{\text{log-sum-exp} \to \text{convex}}$$

  Since $\ln(D)$ is a log-sum-exp of affine functions of x — which is convex —
  and we maximize affine minus convex = concave. This is a standard convex
  problem!

  For CB (per-user denominator):

  $$\ln(\text{SINR}k) = \ln(S_k) + x_k - \underbrace{\ln!\left(\sum_j w{jk}
  e^{x_j} + \text{noise}k\right)}{\text{log-sum-exp}_k \to \text{convex}}$$

  Each constraint $\ln(\text{SINR}_k) \geq \ln(\gamma_k)$ means: convex $\leq$
  affine — a valid convex constraint.

  Line-by-line explanation (GP ZF)

      lse_const = log(p.rho_u * c_err);
  Pre-compute constants: $\ln(\rho_u c_i)$ for each user i. These are the
  constant offsets in the log-sum-exp argument.

          lse = log_sum_exp([lse_const + x; 0]);
  Common denominator in log domain: $\ln(D) = \text{logsumexp}([\ln(\rho_u c_1)
  + x_1, \ldots, \ln(\rho_u c_K) + x_K, 0])$. The trailing 0 accounts for the
  "+1" in the denominator since $e^0 = 1$. CVX recognizes log_sum_exp as a
  convex function.

          maximize(log(a(1)) + x(1) - lse)
  Objective: $\ln(\text{SINR}_1) = \ln(a_1) + x_1 - \ln(D)$ = affine - convex =
  concave. Valid for CVX maximize.

              for k = 2:K
                  log(a(k)) + x(k) - lse >= log(gamma(k));
              end
  QoS: $\ln(a_k) + x_k - \text{lse} \geq \ln(\gamma_k)$, i.e., $\text{lse} \leq
  \ln(a_k) + x_k - \ln(\gamma_k)$. This is convex $\leq$ affine — a valid convex
   constraint.

              x <= 0;
  Power constraint: $\eta_k = e^{x_k} \leq 1 \Leftrightarrow x_k \leq 0$.

      eta = exp(x);
  Recover power coefficients: $\eta_k = e^{x_k}$.

  Line-by-line explanation (GP CB — what's different)

          lse1 = log_sum_exp([log(w(:,1)) + x; log(noise(1))]);
  User 1's denominator: $\ln(D_1) = \text{logsumexp}([\ln(w_{11}) + x_1, \ldots,
   \ln(w_{K1}) + x_K, \ln(\text{noise}1)])$. Unlike ZF's single shared 
  denominator, CB has a per-user denominator with user-specific weights $w{jk}$.

              for k = 2:K
                  lse_k = log_sum_exp([log(w(:,k)) + x; log(noise(k))]);
                  log(S(k)) + x(k) - lse_k >= log(gamma(k));
              end
  Each QoS constraint has its own log-sum-exp $\text{lse}k$ with weights 
  $w{:,k}$ specific to user k. CVX evaluates each one independently.

  ---
  Summary of all power control approaches

  Column 1: Objective
  SCA (Algorithms 1,3): Maximize total rate $\sum_k R_k$
  GP (Algorithms 2,4): Maximize one user's rate $R_1$
  ────────────────────────────────────────
  Column 1: Method
  SCA (Algorithms 1,3): Iterative (DC programming)
  GP (Algorithms 2,4): Single convex solve
  ────────────────────────────────────────
  Column 1: Iterations
  SCA (Algorithms 1,3): ~4 until convergence
  GP (Algorithms 2,4): None (one-shot)
  ────────────────────────────────────────
  Column 1: CVX function
  SCA (Algorithms 1,3): log(affine) in each subproblem
  GP (Algorithms 2,4): log_sum_exp(affine)
  ────────────────────────────────────────
  Column 1: QoS constraints
  SCA (Algorithms 1,3): Linear in eta
  GP (Algorithms 2,4): Convex (log-sum-exp $\leq$ affine)

  Key insight for your future papers

  When you see an optimization with SINR = numerator / denominator where both
  are linear in the power variables:
  1. Write the rate as $R = \log(\text{num} + \text{denom}) -
  \log(\text{denom})$ → DC decomposition
  2. For sum-rate: SCA — linearize the subtracted concave term at each iteration
  3. For single-user: log-domain GP — use log_sum_exp to make the denominator
  convex

  This pattern appears in almost every power control paper in cell-free MIMO,
  massive MIMO, and NOMA.

✻ Cogitated for 16m 23s

❯ /export paper implementation\Cell-free Massive MIMO ZF and CB 
Receiver\chat004_code_implementation_pt3.txt 
  ⎿  Conversation exported to: paper implementation\Cell-free Massive MIMO ZF
     and CB Receiver\chat004_code_implementation_pt3.txt

❯ I want you to implement step 14.                                          
  this:                                                                     
    Step 14: Remaining Figures & Tables                                     
                                                                            
    - Fig 4: Sum rate vs K (sweep users)                                    
    - Fig 5: SCA convergence plot                                           
    - Fig 6: CDF with power control                                         
    - Table 1: Sum rate comparison (EPC vs SCA)                             
    - Table 2: Single-user max rate (GP)                                    
  Then, you will explain me each line of the code so that I can write them  
  on my own if I had to reproduce this paper or similar paper related to    
  wireless.                                                                 
  While, explaining please also mention the part of the paper, you are      
  referring.                                                                
  Write down the equation with proper conventional sign.                    
  Read @"paper implementation/Cell-free Massive MIMO ZF and CB              
  Receiver/chat001_initial_implementation.txt"                              
  And @"paper implementation/Cell-free Massive MIMO ZF and CB               
  Receiver/chat002_code_implementation.txt" for the context                 
  ⎿  Read paper implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\chat001_initial_implementation.txt (470 lines)
  ⎿  Read paper implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\chat002_code_implementation.txt (676 lines)

● I'll read the chat files and then implement all remaining figures and tables.
  Let me first check which files already exist and then write all 6 remaining
  scripts.

● Searched for 1 pattern (ctrl+o to expand)

● Good. I need to create 6 files: main_fig1.m, main_fig4.m, main_fig5.m,
  main_fig6.m, main_table1.m, main_table2.m. Let me write them all now.

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_fig1.m)
  ⎿  Wrote 68 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_fig1.m
     % main_fig1.m — Reproduce Figure 1: Validation of Theorem 1
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Figure 1
     %
     % Compares the closed-form ZF SE (Theorem 1, Eq. 16) with the
     % Monte Carlo ZF SE (exact SINR, Eq. 15) to validate the
     % tight approximation of Theorem 1.
     %
     % Plots per-user SE as a grouped bar chart, averaged over setups.
     % Fixed: M = 60, K = 10, N = 6.
     … +58 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_fig4.m)
  ⎿  Wrote 86 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_fig4.m
     % main_fig4.m — Reproduce Figure 4: Sum spectral efficiency vs K
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Figure 4
     %
     % Plots the sum SE for ZF and CB receivers with equal power control
     % as the number of users K varies from 5 to 30, for N = 2, 4, 6.
     % Pilot length tau = K (orthogonal pilots, no pilot contamination).
     %
     % Fixed: M = 60.

     … +76 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_fig5.m)
  ⎿  Wrote 169 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_fig5.m
     % main_fig5.m — Reproduce Figure 5: SCA convergence
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Figure 5
     %
     % Shows the sum rate increasing monotonically with each SCA iteration
     % for both ZF (Algorithm 1, Eq. 21-29) and CB (Algorithm 3, Eq. 
     36-43).
     % Iteration 0 corresponds to equal power control (eta_k = 1).
     %
     % Requires: CVX toolbox (http://cvxr.com/cvx/)
     % Fixed: M = 60, K = 10, N = 6.
     … +159 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_fig6.m)
  ⎿  Wrote 77 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_fig6.m
     % main_fig6.m — Reproduce Figure 6: CDF with power control
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Figure 6
     %
     % Compares the CDF of per-user SE under:
     %   - Equal Power Control (EPC): eta_k = 1 for all k
     %   - SCA power control (Algorithms 1 & 3): optimized {eta_k}
     % for both ZF and CB receivers.
     %
     % Requires: CVX toolbox (http://cvxr.com/cvx/)
     … +67 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_table1.m)
  ⎿  Wrote 99 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_table1.m
     % main_table1.m — Reproduce Table 1: Sum rate comparison (EPC vs SCA)
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Table 1
     %
     % Compares the sum SE [bits/s/Hz] for:
     %   - ZF with Equal Power Control (EPC) vs SCA (Algorithm 1)
     %   - CB with Equal Power Control (EPC) vs SCA (Algorithm 3)
     % across N = 2, 4, 6 antennas per AP.
     %
     % Requires: CVX toolbox (http://cvxr.com/cvx/)
     … +89 lines (ctrl+o to expand)

● Write(paper implementation\Cell-free Massive MIMO ZF and CB
       Receiver\main_table2.m)
  ⎿  Wrote 96 lines to paper implementation\Cell-free Massive MIMO ZF and 
     CB Receiver\main_table2.m
     % main_table2.m — Reproduce Table 2: Single-user max rate (GP)
     %
     % Paper: Zhang et al. (JCN, 2019), Section IV, Table 2
     %
     % Maximizes User 1's rate (Eq. 30/44) while all other users
     % meet a QoS target of R_bar = 1 bit/s/Hz, using:
     %   - Algorithm 2 (GP for ZF, Eq. 31)
     %   - Algorithm 4 (GP for CB, Eq. 45)
     %
     % Requires: CVX toolbox (http://cvxr.com/cvx/)
     … +86 lines (ctrl+o to expand)

● All 6 files written. Let me update the memory file.

● Wrote 1 memory (ctrl+o to expand)

● Now here are the detailed line-by-line explanations for all 6 scripts:

  ---
  main_fig1.m — Validation of Theorem 1 (Figure 1)

  What this proves

  Figure 1 is the most important validation step in any paper. It proves that
  the closed-form SE expression (Theorem 1, Eq. 16) is a tight approximation of
  the exact SINR (Eq. 15). If these don't match, everything downstream is wrong.

  Key lines explained

  num_setups = 20;
  Fewer setups than the default 100 because Monte Carlo is expensive: each setup
   runs num_channel_real = 300 channel realizations, each requiring ZF detector
  construction (matrix inversion). Total: 20 x 300 = 6000 channel realizations.

      [alpha, c_coeff] = estimate_channel(beta, pilot_index, p);
  Here we need both outputs: alpha for the closed-form (Eq. 16 uses
  $\alpha_{mk}$ directly), and c_coeff for Monte Carlo (Eq. 4 uses $c_{mk}$ to
  generate $\hat{\mathbf{g}}_{mk}$ from received pilots).

      R_ZF_cf = compute_SE_ZF(beta, alpha, pilot_index, p);
  Closed-form (Theorem 1, Eq. 16): Uses $\Omega(k)$, $c_i$, $\mathcal{M}k$ — all
   computed from $\beta{mk}$ and $\alpha_{mk}$ alone. No channel realizations 
  needed.

      R_ZF_mc = compute_SE_ZF_montecarlo(beta, alpha, c_coeff, pilot_index, p);
  Monte Carlo (Eq. 15): For each of 300 realizations, generates $\mathbf{G}$ and
   $\hat{\mathbf{G}}$, builds the ZF detector $\mathbf{A} =
  \hat{\mathbf{G}}(\hat{\mathbf{G}}^H\hat{\mathbf{G}})^{-1}$, computes the exact
   SINR from Eq. 15:

  $$\text{SINR}k^{ZF} = \frac{\rho_u \eta_k}{\sum_m |\mathbf{a}{mk}|^2
  \left[\rho_u \sum_i \eta_i (\beta_{mi} - \alpha_{mi}) + 1\right]}$$

  then averages $\log_2(1 + \text{SINR}_k)$ over realizations.

  [R_ZF_cf_sorted, idx] = sort(R_ZF_cf_avg, 'descend');
  R_ZF_mc_sorted = R_ZF_mc_avg(idx);
  Sort users by rate (strongest user first) so the bar chart has a clean
  decreasing profile. Apply the same permutation to both CF and MC arrays to
  keep user correspondence.

  Expected result: The bars should nearly overlap. Typical relative error < 2%.

  ---
  main_fig4.m — Sum SE vs K (Figure 4)

  What this shows

  How system performance changes as more users join. Two competing effects:
  1. More users = more total throughput (multiplexing gain)
  2. More users = more interference + more pilot overhead (diminishing returns)

  Key lines explained

  K_vec = 5:5:30;
  Sweep from 5 to 30 users. With M=60 APs and N=2 antennas, the system has $MN =
   120$ total receive antennas. ZF requires $MN > K$, so K=30 still works ($120
  > 30$).

      p.K      = K_vec(ik);
      p.tau    = p.K;
      p.prelog = 1 - p.tau / p.T;
  Critical design choice: We set $\tau = K$ (orthogonal pilots for every K).
  This means:
  - No pilot contamination at any K value
  - But pilot overhead increases with K: prelog goes from $1 - 5/200 = 0.975$
  (K=5) to $1 - 30/200 = 0.85$ (K=30)

  This isolates the effect of multiuser interference from pilot contamination.

  The structure is identical to main_fig2.m but sweeps K instead of M. The inner
   N loop reuses the same beta/alpha (which don't depend on N).

  Expected result: Sum rate increases with K but with diminishing returns. ZF
  curves above CB curves. Higher N gives better performance.

  ---
  main_fig5.m — SCA Convergence (Figure 5)

  What this proves

  The SCA algorithm converges monotonically (sum rate never decreases across
  iterations) and quickly (~3-5 iterations). This validates the theoretical
  convergence guarantee.

  Key structural choice: Local functions

  function history = sca_track_ZF(beta, alpha, pilot_index, p, max_iter)
  This is a local function (MATLAB R2016b+) at the bottom of the script. It
  contains the same SCA logic as power_control_SCA_ZF.m but records the sum rate
   at each iteration. Using a local function avoids creating extra files while
  keeping the main script clean.

  Key lines in sca_track_ZF

      eta = ones(K, 1);
      history(1) = sum(compute_SE_ZF(beta, alpha, pilot_index, p, eta));
  Iteration 0 = equal power control. We call compute_SE_ZF with eta = ones(K,1)
  to get the baseline sum rate.

      for iter = 1:max_iter
          D_n = p.rho_u * (c_err' * eta) + 1;
          d   = K * p.rho_u * c_err / D_n;
  At each iteration, compute the current denominator $D^{(n)} = \rho_u \sum_i
  \eta_i c_i + 1$ and the gradient $d_j = K\rho_u c_j / D^{(n)}$.

          cvx_begin quiet
              ...
              obj = -d' * eta_new;
              for k = 1:K
                  obj = obj + log(a(k)*eta_new(k) + p.rho_u*(c_err'*eta_new) +
  1);
              end
              maximize(obj)
  CVX subproblem: concave objective = $\sum_k \ln(a_k \eta_k + D) -
  \mathbf{d}^\top \boldsymbol{\eta}$. Each log(affine) term is concave in CVX's
  DCP framework.

          history(iter+1) = sum(compute_SE_ZF(beta, alpha, pilot_index, p,
  eta));
  After each iteration, compute the actual sum rate (using the Theorem 1
  closed-form, not the surrogate objective). This is what we plot — it shows
  monotonic increase.

  sca_track_CB — same structure, different SINR

                  obj = obj + log(eta_new(k)*S(k) + w(:,k)'*eta_new + noise(k));
                  obj = obj - w(:,k)'*eta_new / D_n(k);
  For CB, each user k has its own denominator $D_k = \mathbf{w}_{:,k}^\top
  \boldsymbol{\eta} + \text{noise}k$, so the linearization penalty is per-user: 
  $-\mathbf{w}{:,k}^\top \boldsymbol{\eta} / D_k^{(n)}$.

  Expected result: Both curves start at EPC (iteration 0) and quickly rise to a
  plateau within 3-5 iterations. ZF curve is above CB.

  ---
  main_fig6.m — CDF with Power Control (Figure 6)

  What this shows

  Compares the fairness of equal power vs SCA-optimized power. The CDF shows how
   individual user rates are distributed. SCA should improve rates (especially
  for weaker users).

  Key lines explained

      rates_ZF_epc(:, s) = compute_SE_ZF(beta, alpha, pilot_index, p);
  EPC: No eta argument — compute_SE_ZF defaults to $\eta_k = 1$ for all k.

      eta_zf = power_control_SCA_ZF(beta, alpha, pilot_index, p);
      rates_ZF_sca(:, s) = compute_SE_ZF(beta, alpha, pilot_index, p, eta_zf);
  SCA: First optimize the power coefficients, then compute per-user SE with the
  optimized eta. Two separate calls because the SCA function returns eta, and we
   compute rates using the Theorem 1 formula.

  [f, x] = ecdf(rates_ZF_epc(:));
  plot(x, f, '-',  'Color', [0 0.45 0.74], 'LineWidth', 1.5);
  [f, x] = ecdf(rates_ZF_sca(:));
  plot(x, f, '--', 'Color', [0 0.45 0.74], 'LineWidth', 1.5);
  Four CDF curves:
  - Solid blue: ZF with EPC
  - Dashed blue: ZF with SCA (should be slightly right of solid)
  - Solid red: CB with EPC
  - Dashed red: CB with SCA

  Expected result: SCA curves shift slightly to the right (higher rates). The
  gain is typically 3-8% in sum rate. The improvement is more visible at the
  median than at the tails.

  ---
  main_table1.m — Sum Rate Comparison (Table 1)

  What this shows

  A clean numerical comparison of EPC vs SCA across antenna configurations.

  Key lines explained

  for in = 1:length(N_vec)
      p.N = N_vec(in);
      for s = 1:num_setups
          ...
          sum_ZF_epc(in) = sum_ZF_epc(in) + sum(compute_SE_ZF(...));
          ...
          eta_zf = power_control_SCA_ZF(beta, alpha, pilot_index, p);
          sum_ZF_sca(in) = sum_ZF_sca(in) + sum(compute_SE_ZF(..., eta_zf));
  For each N value, average the sum SE over 100 setups. The SCA call is inside
  the setup loop because power control depends on the specific $\beta_{mk}$ and
  $\alpha_{mk}$ of each setup.

  fprintf('%-12s', 'ZF gain');
  for in = 1:length(N_vec)
      fprintf('  %-7.1f%%', 100*(sum_ZF_sca(in)/sum_ZF_epc(in) - 1));
  end
  Gain percentage = how much SCA improves over EPC. Paper reports ~3-8% gain.

  Expected output (approximate):
               N = 2     N = 4     N = 6
  ZF, EPC      ~28       ~42       ~55
  ZF, SCA      ~29       ~44       ~58
  CB, EPC      ~18       ~25       ~30
  CB, SCA      ~19       ~26       ~33

  ---
  main_table2.m — Single-User Max Rate (Table 2)

  What this shows

  The maximum achievable rate for one user when all others get exactly the
  minimum QoS. This is the GP result (Algorithms 2 & 4).

  Key lines explained

  R_bar = ones(p.K, 1);         % QoS = 1 bit/s/Hz for all users
  All users have a QoS target of 1 bit/s/Hz. The GP maximizes User 1's rate
  subject to this constraint.

          eta_zf = power_control_GP_ZF(beta, alpha, pilot_index, p, R_bar);
          R_zf   = compute_SE_ZF(beta, alpha, pilot_index, p, eta_zf);
          rate_ZF_user1(in) = rate_ZF_user1(in) + R_zf(1);
          rate_ZF_other(in) = rate_ZF_other(in) + mean(R_zf(2:end));
  - R_zf(1) = User 1's maximized rate (should be much higher than QoS)
  - mean(R_zf(2:end)) = average rate of other users (should be close to 1.0
  bit/s/Hz — the QoS floor)

  Expected output (from the paper):
                      N = 2     N = 4     N = 6
  ZF, User 1          ~7.86     ~9.02     ~9.88
  ZF, Others (avg)    ~1.00     ~1.00     ~1.00
  CB, User 1          ~2.94     ~3.55     ~4.03
  CB, Others (avg)    ~1.00     ~1.00     ~1.00
  ZF / CB ratio       ~2.67x    ~2.54x    ~2.45x

  ZF achieves ~2.5x higher max rate than CB because ZF eliminates inter-user
  interference, allowing one user to grab most of the "freed" resources.

  ---
  Complete file inventory

  File: params.m
  Step: 1
  CVX needed?: No
  What it produces: Parameter struct
  ────────────────────────────────────────
  File: generate_setup.m
  Step: 2
  CVX needed?: No
  What it produces: Beta, AP/UE positions
  ────────────────────────────────────────
  File: assign_pilots.m
  Step: 3
  CVX needed?: No
  What it produces: Pilot index vector
  ────────────────────────────────────────
  File: estimate_channel.m
  Step: 4
  CVX needed?: No
  What it produces: Alpha, c_coeff
  ────────────────────────────────────────
  File: generate_channel.m
  Step: 5
  CVX needed?: No
  What it produces: G, G_hat
  ────────────────────────────────────────
  File: compute_SE_CB.m
  Step: 6
  CVX needed?: No
  What it produces: CB per-user SE
  ────────────────────────────────────────
  File: compute_SE_ZF.m
  Step: 7
  CVX needed?: No
  What it produces: ZF per-user SE
  ────────────────────────────────────────
  File: compute_SE_ZF_montecarlo.m
  Step: 8
  CVX needed?: No
  What it produces: ZF MC per-user SE
  ────────────────────────────────────────
  File: main_fig1.m
  Step: 14
  CVX needed?: No
  What it produces: Fig 1: Validation
  ────────────────────────────────────────
  File: main_fig2.m
  Step: 9
  CVX needed?: No
  What it produces: Fig 2: Sum SE vs M
  ────────────────────────────────────────
  File: main_fig3.m
  Step: 10
  CVX needed?: No
  What it produces: Fig 3: CDF
  ────────────────────────────────────────
  File: main_fig4.m
  Step: 14
  CVX needed?: No
  What it produces: Fig 4: Sum SE vs K
  ────────────────────────────────────────
  File: main_fig5.m
  Step: 14
  CVX needed?: Yes
  What it produces: Fig 5: SCA convergence
  ────────────────────────────────────────
  File: main_fig6.m
  Step: 14
  CVX needed?: Yes
  What it produces: Fig 6: CDF with power ctrl
  ────────────────────────────────────────
  File: main_table1.m
  Step: 14
  CVX needed?: Yes
  What it produces: Table 1: EPC vs SCA
  ────────────────────────────────────────
  File: main_table2.m
  Step: 14
  CVX needed?: Yes
  What it produces: Table 2: GP max rate
  ────────────────────────────────────────
  File: power_control_SCA_ZF.m
  Step: 11
  CVX needed?: Yes
  What it produces: Algorithm 1
  ────────────────────────────────────────
  File: power_control_SCA_CB.m
  Step: 12
  CVX needed?: Yes
  What it produces: Algorithm 3
  ────────────────────────────────────────
  File: power_control_GP_ZF.m
  Step: 13
  CVX needed?: Yes
  What it produces: Algorithm 2
  ────────────────────────────────────────
  File: power_control_GP_CB.m
  Step: 13
  CVX needed?: Yes
  What it produces: Algorithm 4

  All 14 steps are now complete. You can run Figures 1-4 immediately. For
  Figures 5-6 and Tables 1-2, install CVX first from http://cvxr.com/cvx/.

✻ Cogitated for 6m 59s