
           Claude Code v2.1.42
 ▐▛███▜▌   Opus 4.6 · Claude Max
▝▜█████▛▘  D:\Personal\Awesome-Wireless-Communications
  ▘▘ ▝▝    Opus 4.6 is here · $50 free extra usage · /extra-usage to enable

❯ I want you to help me implement this paper:                               
  D:\Personal\Awesome-Wireless-Communications\papers\Cell-Free\001_All      
  Paper(without review paper)\Cell-free_massive_MIMO_Zero_forcing_and_conju 
  gate_beamforming_receivers.pdf                                            
  ------------------------------                                            
  Code will be in Matlab.                                                   
  Don't just start writing code. Your main objctive is to help me learn how 
   to write code so that I can implement any paper on my own next time.     
  You will first give me a comprehensive plan on how to implement or        
  reproduce the paper.                                                      
  Then, we will write code for each single part one at a time.              
  Divide the implementation part into as small section as possible.         
  Do deep research on web, github or on other similar relevant platforms to 
   see if you can find me codes already existed for this paer so that you   
  can utilize those knowledge.                                              
  you can take help from this two files:                                    
  D:\Personal\Awesome-Wireless-Communications\chat\chat006_analyze_Cell-fre 
  e_massive_MIMO_Zero_forcing_and_conjugate_beamforming_receivers.txt       
  D:\Personal\Awesome-Wireless-Communications\docs\Cell-Free-Massive-MIMO-Z 
  F-and-CB-Receivers-Detailed-Analysis.md                                   
  The code should be as minimal as possible.                                
  Should follow standart practices and looks like that a PhD students has   
  written it.                                                               
  Should maintain clean code principles.                                    

● Let me start by reading the paper and your existing analysis files, and
  searching for existing implementations online.

● Read 3 files (ctrl+o to expand)

● Let me read the chat file and search for existing implementations online.

● Read 1 file (ctrl+o to expand)

● Task(Search existing implementations)
  ⎿  Done (48 tool uses · 63.3k tokens · 14m 6s)
  (ctrl+o to expand)

● Excellent. I now have a thorough understanding of the paper and all existing
  open-source code. Let me enter plan mode to design a comprehensive
  implementation plan.

● Entered plan mode
  Claude is now exploring and designing an implementation approach.

● Let me check the existing project structure first.

● Searched for 1 pattern, read 2 files (ctrl+o to expand)

● Good — the implementation directory already exists but is empty. Now let me
  write the comprehensive plan.

● Updated plan
  ⎿  /plan to preview

● Before I finalize, let me clarify a few things:

● User answered Claude's questions:
  ⎿  · Do you have CVX toolbox installed in MATLAB? It's needed for the 
     power control optimization steps (Steps 11-13). → I'll install it later

     · Which figures/tables from the paper do you want to reproduce? Select 
     all that apply. → All figures & tables

     · For the path loss model, the paper references a 3GPP model but the 
     exact formula isn't always explicit. Should I use the standard model 
     from Ngo et al. 2017 (the foundational cell-free paper)? → Yes, use Ngo
      2017 model (Recommended)

● Good. All answers are clear. The plan is comprehensive and accounts for all
  figures/tables with CVX to be installed later. Let me finalize.
  ⎿  Tool use rejected with user message: I will start implement later. First 
     let me understand the plan and ask you questions if I have any.

● Take your time to review the plan. Here's a quick summary of what we'll do:

  14 steps, each building on the previous one:

  Step: 1
  What: Simulation parameters
  Key Equations: Section IV
  Output: params.m
  ────────────────────────────────────────
  Step: 2
  What: Network topology + beta_mk
  Key Equations: Eq. 1 (path loss)
  Output: generate_setup.m
  ────────────────────────────────────────
  Step: 3
  What: Pilot assignment
  Key Equations: phi_k sequences
  Output: pilot_index vector
  ────────────────────────────────────────
  Step: 4
  What: MMSE estimation parameters (alpha, c)
  Key Equations: Eq. 5, 8
  Output: estimate_channel.m (Part A)
  ────────────────────────────────────────
  Step: 5
  What: Channel realization + estimation
  Key Equations: Eq. 2-4
  Output: generate_channel.m + Part B
  ────────────────────────────────────────
  Step: 6
  What: CB spectral efficiency (closed-form)
  Key Equations: Eq. 33-35 (Lemma 1)
  Output: compute_SE_CB.m
  ────────────────────────────────────────
  Step: 7
  What: ZF spectral efficiency (closed-form)
  Key Equations: Eq. 16-20 (Theorem 1)
  Output: compute_SE_ZF.m
  ────────────────────────────────────────
  Step: 8
  What: ZF Monte Carlo validation
  Key Equations: Eq. 15
  Output: compute_SE_ZF_montecarlo.m
  ────────────────────────────────────────
  Step: 9
  What: Figure 2 (sum rate vs M)
  Key Equations: —
  Output: main_fig2.m
  ────────────────────────────────────────
  Step: 10
  What: Figure 3 (CDF of per-user rate)
  Key Equations: —
  Output: main_fig3.m
  ────────────────────────────────────────
  Step: 11
  What: SCA power control for ZF
  Key Equations: Eq. 21-29 (Alg. 1)
  Output: power_control_SCA_ZF.m
  ────────────────────────────────────────
  Step: 12
  What: SCA power control for CB
  Key Equations: Eq. 36-43 (Alg. 3)
  Output: power_control_SCA_CB.m
  ────────────────────────────────────────
  Step: 13
  What: GP single-user max for ZF/CB
  Key Equations: Eq. 30-31, 44-45 (Alg. 2,4)
  Output: power_control_GP_*.m
  ────────────────────────────────────────
  Step: 14
  What: All remaining figures/tables
  Key Equations: —
  Output: main_fig*.m, main_table*.m

  The core idea: Steps 1-8 give you a fully working, validated simulation
  pipeline. Step 9 is the first "paper figure" and proves everything works.
  Steps 10-14 extend to all results.

  Feel free to ask questions about any step — the math behind it, why we do
  things in this order, what a specific equation means, or anything else.

✻ Churned for 11m 47s

❯ Write me the plan in this chat.  

● Read 1 file (ctrl+o to expand)

● Here is the full implementation plan:

  ---
  Implementation Plan: Cell-Free Massive MIMO — ZF and CB Receivers

  Context

  Paper: "Cell-Free Massive MIMO: Zero Forcing and Conjugate Beamforming
  Receivers"
  Authors: Yao Zhang, Haotong Cao, Meng Zhou, Longxiang Yang (JCN, 2019)
  Goal: Reproduce the paper's simulation results (Figures 1-6, Tables 1-2) in
  MATLAB, learning how to implement wireless communication papers step-by-step.
  Target Directory: Paper Implementation\Cell-free Massive MIMO ZF and CB 
  Receiver\

  ---
  Teaching Philosophy

  Each step builds on the previous one. We write one small, testable function at
   a time. After each step, you run it, verify the output makes physical sense,
  and understand every line before moving on. This is how PhD students learn —
  incrementally, with sanity checks at every stage.

  ---
  Reference Repositories (for learning, NOT copy-paste)

  Repository: https://github.com/emilbjornson/cell-free-book
  What to learn from it: Network setup, channel estimation, SE computation
    patterns
  ────────────────────────────────────────
  Repository:
  https://github.com/hienquocngo/Cell-Free-Massive-MIMO-Versus-Small-Cells
  What to learn from it: CB receiver baseline, max-min power control
  ────────────────────────────────────────
  Repository: https://github.com/tranlenam/cellfreeMIMOenergyefficiency
  What to learn from it: SCA approximation functions

  ---
  File Structure

  Cell-free Massive MIMO ZF and CB Receiver/
  ├── main_fig2.m                % Reproduces Figure 2 (sum rate vs M)
  ├── main_fig3.m                % Reproduces Figure 3 (CDF of per-user rate)
  ├── main_fig4.m                % Reproduces Figure 4 (sum rate vs K)
  ├── main_fig5.m                % Reproduces Figure 5 (SCA convergence)
  ├── main_fig6.m                % Reproduces Figure 6 (per-user rate CDF with
  power control)
  ├── main_table1.m              % Reproduces Table 1 (sum rate comparison)
  ├── main_table2.m              % Reproduces Table 2 (single-user max rate)
  ├── generate_setup.m           % Network topology + large-scale fading
  ├── generate_channel.m         % Small-scale fading channel realization
  ├── estimate_channel.m         % MMSE channel estimation (Eq. 4-8)
  ├── compute_SE_ZF.m            % ZF spectral efficiency (Theorem 1, Eq. 16)
  ├── compute_SE_CB.m            % CB spectral efficiency (Lemma 1, Eq. 33)
  ├── compute_SE_ZF_montecarlo.m % ZF SE via Monte Carlo (Eq. 15, for
  validation)
  ├── power_control_SCA_ZF.m     % Algorithm 1: SCA for ZF sum-rate max
  ├── power_control_SCA_CB.m     % Algorithm 3: SCA for CB sum-rate max
  ├── power_control_GP_ZF.m      % Algorithm 2: GP for ZF single-user max
  ├── power_control_GP_CB.m      % Algorithm 4: GP for CB single-user max
  └── params.m                   % Default simulation parameters


  ---
  Implementation Steps (14 Steps)

  Step 1: Simulation Parameters (params.m)

  What you learn: How to organize simulation constants cleanly.
  What to code: A function that returns a struct with all paper parameters:
  - M=60, K=10, N=2/4/6, tau=10, T=200
  - rho_p, rho_u (pilot and data SNR in linear scale)
  - Area size (1 km x 1 km), path loss exponent, shadow fading std dev
  - Pre-log factor: (1 - tau/T)

  Sanity check: Print all parameters, verify they match the paper's Section IV.

  ---
  Step 2: Network Topology & Large-Scale Fading (generate_setup.m)

  What you learn: How to model AP/user placement and path loss.
  What to code:
  1. Place M APs uniformly in the area (random or grid)
  2. Place K users uniformly at random
  3. Compute distances d_mk between each AP m and user k
  4. Compute beta_mk using the Ngo et al. 2017 three-slope path loss model:
    - Three-slope model with shadow fading (sigma_sf = 8 dB)
    - beta_mk = 10^(PL_mk / 10) where PL is in dB
  5. Use wrap-around to avoid edge effects (1x1 km area)

  Output: beta (M x K matrix), AP positions, user positions
  Sanity check: Plot AP and user positions. Verify beta_mk values range
  ~10^(-14) to 10^(-8).

  ---
  Step 3: Pilot Assignment

  What you learn: How pilot contamination arises.
  What to code:
  1. When tau >= K: Assign orthogonal pilots (phi_i^H * phi_k = delta_ik)
  2. When tau < K: Random pilot assignment — each user picks one of tau
  orthogonal pilots
  3. Store pilot_index(k) for each user

  Output: pilot_index (K x 1 vector)
  Sanity check: tau=10, K=10 → all orthogonal. tau=8, K=10 → 2 users share
  pilots.

  ---
  Step 4: MMSE Channel Estimation Parameters (estimate_channel.m — Part A)

  What you learn: How MMSE estimation works in closed form.
  What to code:
  1. Compute c_mk (Eq. 5) — the MMSE filter coefficient
  2. Compute alpha_mk (Eq. 8) — the channel estimate variance
  3. These depend ONLY on beta_mk and pilot assignments (not on channel
  realizations)

  Output: alpha (M x K matrix), c_coeff (M x K matrix)
  Sanity check:
  - alpha_mk <= beta_mk always
  - No pilot sharing + high SNR → alpha_mk ≈ beta_mk
  - With pilot contamination → alpha_mk < beta_mk even at high SNR

  ---
  Step 5: Channel Realization & MMSE Estimation (generate_channel.m +
  estimate_channel.m — Part B)

  What you learn: How to generate one Monte Carlo realization.
  What to code:
  1. Generate h_mk ~ CN(0, I_N) for all m, k
  2. True channel: g_mk = sqrt(beta_mk) * h_mk
  3. Generate pilot noise W_m,p
  4. Received pilot signal Y_m,p (Eq. 2)
  5. De-spread: Y_tilde_mk,p (Eq. 3)
  6. Estimate: g_hat_mk = c_mk * Y_tilde_mk,p (Eq. 4)

  Output: G (MN x K), G_hat (MN x K)
  Sanity check:
  - norm(G_hat(:,k))^2 ≈ N * sum(alpha(:,k)) on average
  - norm(G(:,k) - G_hat(:,k))^2 ≈ N * sum(beta(:,k) - alpha(:,k))

  ---
  Step 6: CB Spectral Efficiency — Closed Form (compute_SE_CB.m)

  What you learn: How to compute SE from closed-form expressions (no Monte 
  Carlo).
  What to code: Implement Lemma 1 (Eq. 33-35):
  1. l_ik vectors (Eq. 34) — coherent interference
  2. theta_ik vectors (Eq. 35) — non-coherent interference
  3. SINR_k^CB using Eq. 33
  4. R_k^CB = pre_log * log2(1 + SINR_k^CB)

  Output: R_CB (K x 1)
  Sanity check: Per-user ~1-5 bits/s/Hz. Sum rate ~20-35 for M=60, K=10, N=6.

  ---
  Step 7: ZF Spectral Efficiency — Closed Form (compute_SE_ZF.m)

  What you learn: The paper's novel Theorem 1.
  What to code: Implement Theorem 1 (Eq. 16-20):
  1. c_i = max_m(beta_mi - alpha_mi) for each user i (Eq. 17)
  2. M_k — the set of contributing APs for user k (Eq. 19-20)
  3. Omega(k) — the effective array gain (Eq. 18)
  4. SINR_k^ZF using Eq. 16
  5. R_k^ZF = pre_log * log2(1 + SINR_k^ZF)

  Output: R_ZF (K x 1)
  Sanity check: ZF rates > CB rates (~1.5-2x). Sum rate ~40-60 for M=60, K=10,
  N=6.

  ---
  Step 8: ZF SE — Monte Carlo Validation (compute_SE_ZF_montecarlo.m)

  What you learn: How to validate closed-form expressions with simulation.
  What to code:
  1. For each of ~300 realizations:
  a. Generate channel (Step 5)
  b. Build ZF detector: A = G_hat * inv(G_hat' * G_hat)
  c. Compute exact SINR_k from Eq. 15
  d. R_k = log2(1 + SINR_k)
  2. Average over realizations

  Output: R_ZF_mc (K x 1)
  Sanity check: R_ZF_mc ≈ R_ZF from Step 7 → validates Theorem 1 (reproduces
  Fig. 1).

  ---
  Step 9: Reproduce Figure 2 — Sum Rate vs M (main_fig2.m)

  What you learn: How performance scales with M; first complete simulation
  script.
  What to code:
  1. Sweep M = [20, 30, 40, 50, 60, 70, 80]
  2. Multiple random network realizations per M
  3. Compute R_ZF and R_CB with equal power (eta_k = 1)
  4. Average sum rates, plot for N=2, N=4, N=6

  Produces: Figure 2 — validates your entire pipeline.

  ---
  Step 10: Reproduce Figure 3 — CDF of Per-User Rate (main_fig3.m)

  What you learn: CDF plots, fairness, outage behavior.
  What to code:
  1. Fix M=60, K=10, many random setups
  2. Collect all per-user rates
  3. Plot empirical CDF for ZF/CB, different N and tau values

  Produces: Figure 3.

  ---
  Step 11: SCA Power Control for ZF (power_control_SCA_ZF.m)

  What you learn: Sequential Convex Approximation — fundamental optimization
  technique.
  What to code (Algorithm 1):
  1. Initialize feasible (zeta_k, t_k)
  2. Linearize non-convex rate via first-order Taylor (Eq. 24-28)
  3. Solve convex subproblem with CVX
  4. Check convergence: |sum(t_new - t_old)| < epsilon
  5. Return eta_k = zeta_k^2

  Requires: CVX toolbox
  Sanity check: Sum rate improves monotonically (Fig. 5).

  ---
  Step 12: SCA Power Control for CB (power_control_SCA_CB.m)

  What you learn: Same SCA applied to CB's SINR structure.
  What to code: Algorithm 3 (same framework, CB SINR terms from Eq. 36-43).

  ---
  Step 13: GP Power Control — Single User Max (power_control_GP_ZF.m,
  power_control_GP_CB.m)

  What you learn: Geometric Programming.
  What to code (Algorithms 2 & 4):
  1. Maximize R_1 s.t. R_k >= R_bar (k=2..K), 0 <= eta_k <= 1
  2. Transform to GP form, solve with CVX (gp_mode)

  Output: Table 2 values.

  ---
  Step 14: Remaining Figures & Tables

  - Fig 4: Sum rate vs K (sweep users)
  - Fig 5: SCA convergence plot
  - Fig 6: CDF with power control
  - Table 1: Sum rate comparison (EPC vs SCA)
  - Table 2: Single-user max rate (GP)

  ---
  Dependency Order

  Step 1 (params)
    └── Step 2 (setup/beta)
          └── Step 3 (pilots)
                └── Step 4 (alpha, c_mk)
                      ├── Step 5 (channel realization)
                      ├── Step 6 (CB closed-form SE)
                      └── Step 7 (ZF closed-form SE)
                            └── Step 8 (ZF Monte Carlo validation)
                                  └── Step 9 (Fig 2) ──── "Pipeline validated!"
                                        ├── Step 10 (Fig 3)
                                        ├── Step 11 (SCA-ZF)
                                        ├── Step 12 (SCA-CB)
                                        ├── Step 13 (GP)
                                        └── Step 14 (All remaining
  figures/tables)


  ---
  Key MATLAB Conventions

  - All matrices follow the paper's notation: G is MN x K, beta is M x K
  - Use 1i (not j or i) for imaginary unit to avoid variable shadowing
  - Use (1/sqrt(2))*(randn(...) + 1i*randn(...)) for CN(0,1) generation
  - Functions return values; scripts produce plots
  - Every function has a header comment with the equation number it implements

  ---
  Verification Strategy

  ┌───────────────────┬───────────────────────────────────────────────────────┐
  │    Checkpoint     │                    What to verify                     │
  ├───────────────────┼───────────────────────────────────────────────────────┤
  │ After Steps 1-5   │ Statistical properties of channels and estimates      │
  ├───────────────────┼───────────────────────────────────────────────────────┤
  │ After Steps 6-7   │ CB vs ZF rates — ZF should be higher                  │
  ├───────────────────┼───────────────────────────────────────────────────────┤
  │ After Step 8      │ Monte Carlo ≈ closed-form (validates Theorem 1)       │
  ├───────────────────┼───────────────────────────────────────────────────────┤
  │ After Step 9      │ Figure 2 matches the paper — full pipeline validation │
  ├───────────────────┼───────────────────────────────────────────────────────┤
  │ After Steps 11-13 │ Power-controlled rates > equal power rates            │
  └───────────────────┴───────────────────────────────────────────────────────┘

  ---
  Take your time reviewing this. When you're ready to start or have questions
  about any step, just let me know.

✻ Baked for 51s

❯ /export paper implementation/Cell-free Massive MIMO ZF and CB 
Receiver/chat001_initial_implementation.txt 
  ⎿  Conversation exported to: paper implementation/Cell-free Massive MIMO ZF
     and CB Receiver/chat001_initial_implementation.txt

❯ Okay, Start implementing till step 2.                                     
  But for this,                                                             
    1. Place M APs uniformly in the area (random or grid)                   
  I want to use grid but tell me what is the difference between two?        

● Random vs Grid AP Placement

  Grid placement: APs are placed at fixed, evenly-spaced positions forming a
  regular grid pattern. For M=60 APs in a 1x1 km area, you'd place them on a
  ~8x8 grid (closest to 60).

  Random placement: APs are dropped at uniformly random (x,y) coordinates within
   the area.

  Key differences:

  ┌─────────────────┬───────────────────────┬──────────────────────────────────┐
  │     Aspect      │         Grid          │              Random              │
  ├─────────────────┼───────────────────────┼──────────────────────────────────┤
  │ Reproducibility │ Same positions every  │ Different every run (unless you  │
  │                 │ run                   │ fix the seed)                    │
  ├─────────────────┼───────────────────────┼──────────────────────────────────┤
  │ Coverage        │ Uniform — no gaps, no │ May have gaps and clusters by    │
  │                 │  clustering           │ chance                           │
  ├─────────────────┼───────────────────────┼──────────────────────────────────┤
  │                 │ Less realistic (real  │ More realistic (APs placed where │
  │ Realism         │ deployments aren't    │  infrastructure allows)          │
  │                 │ perfect grids)        │                                  │
  ├─────────────────┼───────────────────────┼──────────────────────────────────┤
  │ What most       │ Used when M is a      │ Most cell-free papers (including │
  │ papers do       │ perfect square        │  Ngo 2017, Bjornson's book) use  │
  │                 │                       │ random for both APs and users    │
  ├─────────────────┼───────────────────────┼──────────────────────────────────┤
  │ Effect on       │ Slightly optimistic   │ Slightly more variance across    │
  │ results         │ (uniform coverage)    │ setups                           │
  └─────────────────┴───────────────────────┴──────────────────────────────────┘

  What this paper likely does: The paper doesn't explicitly state, but the
  reference papers (Ngo 2017) use random placement for both APs and users.
  However, grid is perfectly fine for learning — it removes one source of
  randomness, making debugging easier.

  My recommendation: Use grid for APs (easier to debug, deterministic), random
  for users (must be random to model real scenarios). This is what we'll do.

  Now let's implement Steps 1 and 2.

● Step 1: params.m

● Write(Paper Implementation\Cell-free Massive MIMO ZF and CB Receiver\params.m)
  ⎿  Wrote 1 lines to Paper Implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\params.m

     function p = params()
     %PARAMS Default simulation parameters for Zhang et al. (JCN, 2019).
     %   "Cell-Free Massive MIMO: Zero Forcing and Conjugate Beamforming 
     Receivers"
     %
     %   Usage: p = params();
     %
     %   All parameters match the paper's Section IV (Numerical Results).

         % --- Network geometry ---
         p.area_side = 1000;         % Area side length [m] (1 km x 1 km 
     square)

● Let me explain params.m line by line before moving on:

  Why normalized SNR? In wireless communications, we normalize everything by
  noise power. Instead of working with absolute powers (200 mW transmit,
  10^(-9.6) mW noise), we work with the ratio rho = transmit_power / 
  noise_power. This simplifies all equations — the noise term in SINR
  expressions becomes just 1 instead of sigma^2.

  The calculation:
  - Noise = -96 dBm → 10^(-96/10) mW = 2.51 × 10^(-10) mW
  - rho_p = 200 / (2.51 × 10^(-10)) ≈ 7.96 × 10^11 (very high, ~119 dB)

  This large value is correct — it represents the ratio of transmit power to
  thermal noise before path loss. The actual received SNR will be much lower
  after channel attenuation (beta_mk is ~10^(-8) to 10^(-14)).

  ---
  Step 2: generate_setup.m

  Now let me explain the Ngo 2017 three-slope path loss model before writing it.
   This model has three distance regions:

  Path Loss (dB) = {
    -L - 15*log10(d1) - 20*log10(d0),                 if d <= d0     (very
  close)
    -L - 15*log10(d1) - 20*log10(d),                  if d0 < d <= d1 (near
  field)
    -L - 35*log10(d),                                  if d > d1      (far
  field)
  }

  where L = 46.3 + 33.9*log10(f) - 13.82*log10(hAP) - (1.1*log10(f)-0.7)*hUE +
  (1.56*log10(f)-0.8)


  The slopes are 0 (flat), -20 dB/decade, -35 dB/decade — hence "three-slope."

  Wrap-around: Since users near the area edge would unrealistically see fewer
  nearby APs, we "tile" the area into 9 copies (like a torus). For each AP-user
  pair, we take the minimum distance across all 9 copies.

● Write(Paper Implementation\Cell-free Massive MIMO ZF and CB
       Receiver\generate_setup.m)
  ⎿  Wrote 1 lines to Paper Implementation\Cell-free Massive MIMO ZF and CB 
     Receiver\generate_setup.m

     function [beta, ap_pos, ue_pos] = generate_setup(p)
     %GENERATE_SETUP Generate network topology and large-scale fading 
     coefficients.
     %   [beta, ap_pos, ue_pos] = generate_setup(p)
     %
     %   Places M APs on a grid, K users randomly, computes beta_mk using 
     the
     %   three-slope path loss model from Ngo et al. (IEEE TWC, 2017) with
     %   wrap-around and log-normal shadow fading.
     %
     %   Inputs:
     %       p       - Parameter struct from params()

● Let me walk you through the key parts of generate_setup.m:

  ---
  Grid placement logic

  M_per_side = ceil(sqrt(p.M));       % For M=60: ceil(7.74) = 8 → 8x8 = 64 grid
   points
  spacing = D / M_per_side;           % 1000/8 = 125 m between APs
  Then we take the first 60 of those 64 grid points. The grid centers start at
  spacing/2 (= 62.5m) from the edge, so APs are evenly inset.

  Wrap-around explained visually

    +-------+-------+-------+
    | copy  | copy  | copy  |
    +-------+-------+-------+
    | copy  | REAL  | copy  |    ← User sees 9 copies of the area
    +-------+-------+-------+
    | copy  | copy  | copy  |
    +-------+-------+-------+


  For each AP-user pair, we compute 9 distances (one per copy) and take the
  minimum. This means a user at position (10, 500) will "see" an AP at (990,
  500) as only 20m away (wrapping around), not 980m.

  Three-slope path loss

  The model has three regions based on distance:

  ┌────────┬───────────────┬──────────────┬────────────────────────────────────┐
  │ Region │   Distance    │    Slope     │          Physical meaning          │
  ├────────┼───────────────┼──────────────┼────────────────────────────────────┤
  │ 1      │ d <= 10m      │ 0 dB/decade  │ Almost no extra loss (very close)  │
  ├────────┼───────────────┼──────────────┼────────────────────────────────────┤
  │ 2      │ 10m < d <=    │ -20          │ Free-space-like propagation        │
  │        │ 50m           │ dB/decade    │                                    │
  ├────────┼───────────────┼──────────────┼────────────────────────────────────┤
  │ 3      │ d > 50m       │ -35          │ Urban propagation with             │
  │        │               │ dB/decade    │ obstructions                       │
  └────────┴───────────────┴──────────────┴────────────────────────────────────┘

  The constant L comes from the Hata-COST231 empirical model and depends on
  carrier frequency and antenna heights.

  What beta_mk values should look like

  For our parameters:
  - Close AP (d ≈ 50m): beta ≈ 10^(-8.5) → strong channel
  - Far AP (d ≈ 500m): beta ≈ 10^(-12.5) → weak channel
  - Range: roughly 10^(-8) to 10^(-14)

  ---
  You can now test both files in MATLAB with:

  p = params();
  [beta, ap_pos, ue_pos] = generate_setup(p);

  % Sanity checks
  fprintf('beta range: [%.2e, %.2e]\n', min(beta(:)), max(beta(:)));
  fprintf('beta mean:  %.2e\n', mean(beta(:)));

  % Visualize
  figure;
  plot(ap_pos(:,1), ap_pos(:,2), 'r^', 'MarkerSize', 8, 'LineWidth', 1.5); hold 
  on;
  plot(ue_pos(:,1), ue_pos(:,2), 'bo', 'MarkerSize', 8, 'LineWidth', 1.5);
  legend('APs', 'Users'); xlabel('x [m]'); ylabel('y [m]');
  title('Network Layout'); axis equal; grid on;
  xlim([0 1000]); ylim([0 1000]);

  Run this and let me know what beta values and plot you get. Once this looks
  good, we move to Step 3 (pilot assignment).

✻ Cogitated for 1m 35s